diff --git a/docker-compose.yml b/docker-compose.yml
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/docker-compose.yml
@@ -0,0 +1,24 @@
+version: '3.8'
+
+services:
+  # The Database
+  mongo:
+    image: mongo:latest
+    container_name: wordsynk-mongo
+    restart: always
+    ports:
+      - "27017:27017"
+    volumes:
+      - mongo-data:/data/db
+
+  # The Web GUI (Optional)
+  mongo-express:
+    image: mongo-express
+    container_name: wordsynk-admin
+    restart: always
+    ports:
+      - "8081:8081"
+    environment:
+      ME_CONFIG_MONGODB_ADMINUSERNAME: admin
+      ME_CONFIG_MONGODB_ADMINPASSWORD: pass
+      ME_CONFIG_MONGODB_URL: mongodb://mongo:27017/
+    depends_on:
+      - mongo
+
+volumes:
+  mongo-data:
diff --git a/rust-core/wordsynk-ghost/.env.example b/rust-core/wordsynk-ghost/.env.example
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/rust-core/wordsynk-ghost/.env.example
@@ -0,0 +1,18 @@
+# ---------------------------------------------------------
+# WORDSYNK GHOST CONFIGURATION
+# ---------------------------------------------------------
+
+# 1. AUTHENTICATION (CRITICAL)
+# Copy from Mitmproxy request headers (Authorization: Bearer ...)
+WORDSYNK_TOKEN=
+
+# 2. TARGET IDENTIFIERS (From your Mitmproxy logs)
+# You MUST fill these in. The script will fail without them.
+SUPER_USER_ID=
+SUPPLIER_ID=
+
+# 3. DATABASE
+MONGO_URI=mongodb://localhost:27017
+DB_NAME=wordsynk_live
+
+# 4. LOGGING
+RUST_LOG=info
diff --git a/rust-core/wordsynk-ghost/Cargo.toml b/rust-core/wordsynk-ghost/Cargo.toml
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/rust-core/wordsynk-ghost/Cargo.toml
@@ -0,0 +1,15 @@
+[package]
+name = "wordsynk-ghost"
+version = "0.2.0"
+edition = "2021"
+
+[dependencies]
+reqwest = { version = "0.11", features = ["json", "blocking", "rustls-tls", "gzip"] }
+tokio = { version = "1", features = ["full"] }
+serde = { version = "1.0", features = ["derive"] }
+serde_json = "1.0"
+chrono = "0.4"
+anyhow = "1.0"
+log = "0.4"
+env_logger = "0.10"
+mongodb = "2.7"
+bson = { version = "2.7", features = ["chrono-0_4"] }
+dotenv = "0.15"
diff --git a/rust-core/wordsynk-ghost/src/headers.rs b/rust-core/wordsynk-ghost/src/headers.rs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/rust-core/wordsynk-ghost/src/headers.rs
@@ -0,0 +1,15 @@
+use reqwest::header::{HeaderMap, HeaderValue, AUTHORIZATION, ACCEPT, USER_AGENT, ACCEPT_ENCODING};
+
+pub fn generate_mobile_headers(token: &str) -> HeaderMap {
+    let mut headers = HeaderMap::new();
+
+    // 1. Authorization
+    let auth_value = format!("Bearer {}", token);
+    headers.insert(AUTHORIZATION, HeaderValue::from_str(&auth_value).unwrap());
+
+    // 2. Mobile User Agent
+    headers.insert(USER_AGENT, HeaderValue::from_static("okhttp/4.9.2"));
+
+    // 3. Accept Headers
+    headers.insert(ACCEPT, HeaderValue::from_static("application/json"));
+    headers.insert(ACCEPT_ENCODING, HeaderValue::from_static("gzip"));
+
+    headers
+}
diff --git a/rust-core/wordsynk-ghost/src/main.rs b/rust-core/wordsynk-ghost/src/main.rs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/rust-core/wordsynk-ghost/src/main.rs
@@ -0,0 +1,142 @@
+mod headers;
+mod storage;
+
+use anyhow::Result;
+use log::{info, error, debug, warn};
+use reqwest::Client;
+use serde::Deserialize;
+use serde_json::Value;
+use std::env;
+use std::time::Duration;
+use tokio::time::sleep;
+
+// CONSTANTS
+const HOST: &str = "https://gateway-uk.wordsynk.com";
+const BOOKING_ENDPOINT: &str = "/ws-booking/Bookings/Requirement";
+const OFFER_ENDPOINT: &str = "/ws-offer/offers";
+const POLL_INTERVAL_MS: u64 = 2000; 
+
+// MONGO CONFIG
+const MONGO_URI: &str = "mongodb://localhost:27017";
+const DB_NAME: &str = "wordsynk_live";
+
+// Header Structure based on your dump
+#[derive(Debug, Deserialize)]
+#[serde(rename_all = "PascalCase")] 
+struct PaginationHeader {
+    current_page: u64,
+    page_size: u64,
+    total_count: u64,
+    total_pages: u64,
+    has_previous: bool,
+    has_next: bool,
+}
+
+#[tokio::main]
+async fn main() -> Result<()> {
+    if env::var("RUST_LOG").is_err() {
+        env::set_var("RUST_LOG", "info");
+    }
+    env_logger::init();
+    dotenv::dotenv().ok();
+
+    info!("üöú WORDSYNK SYNC ENGINE: Initializing...");
+
+    // 1. Init Database
+    let db = storage::Storage::new(MONGO_URI, DB_NAME).await?;
+    info!("üíæ Connected to MongoDB at {} [{}]", MONGO_URI, DB_NAME);
+
+    // 2. Load Config
+    let token = env::var("WORDSYNK_TOKEN").expect("WORDSYNK_TOKEN env var required");
+    
+    // IDs - STRICT MODE: No defaults to avoid ban risk.
+    let super_user_id = env::var("SUPER_USER_ID").expect("SUPER_USER_ID env var required");
+    let supplier_id = env::var("SUPPLIER_ID").expect("SUPPLIER_ID env var required");
+    // Note: 'supplierRef' was not used in the verified Offers URL, so removing requirement for it unless needed later.
+
+    let client = Client::builder()
+        .danger_accept_invalid_certs(true)
+        .build()?;
+
+    loop {
+        // --- STEP 1: SYNC BOOKINGS (With Pagination) ---
+        info!("üîÑ Starting Sync Cycle...");
+        
+        let booking_base_url = format!(
+            "{}{}?superUserId={}&pageSize=1000&requirementSupplierId={}", 
+            HOST, BOOKING_ENDPOINT, super_user_id, supplier_id
+        );
+        
+        // Using "id" as unique key based on provided JSON dump
+        if let Err(e) = sync_all_pages(&client, &token, &booking_base_url, "bookings", "id", &db).await {
+            error!("‚ùå Sync Bookings Failed: {}", e);
+        }
+
+        sleep(Duration::from_millis(100)).await;
+
+        // --- STEP 2: SYNC OFFERS ---
+        // Updated to user-provided pattern: /ws-offer/offers?supplierId=...
+        let offer_base_url = format!(
+            "{}{}?supplierId={}&isAvailable=true&isAccepted=false&isDeleted=false",
+            HOST, OFFER_ENDPOINT, supplier_id
+        );
+
+        // Using "id" as unique key (standard assumption, verify with harvest if fails)
+        if let Err(e) = sync_all_pages(&client, &token, &offer_base_url, "offers", "id", &db).await {
+            error!("‚ùå Sync Offers Failed: {}", e);
+        }
+
+        info!("üí§ Sleeping {}ms...", POLL_INTERVAL_MS);
+        sleep(Duration::from_millis(POLL_INTERVAL_MS)).await;
+    }
+}
+
+async fn sync_all_pages(
+    client: &Client, 
+    token: &str, 
+    base_url: &str, 
+    collection: &str,
+    unique_key: &str,
+    db: &storage::Storage
+) -> Result<()> {
+    let mut page = 1;
+    let mut total_pages = 1;
+
+    loop {
+        let url = format!("{}&page={}", base_url, page);
+        debug!("   -> Fetching {} Page {}", collection, page);
+
+        let response = client.get(&url)
+            .headers(headers::generate_mobile_headers(token))
+            .send()
+            .await?;
+
+        if !response.status().is_success() {
+            return Err(anyhow::anyhow!("API Error {}: {}", url, response.status()));
+        }
+
+        // 1. Parse Pagination Header
+        if let Some(header_val) = response.headers().get("X-Pagination") {
+            if let Ok(header_str) = header_val.to_str() {
+                match serde_json::from_str::<PaginationHeader>(header_str) {
+                    Ok(ph) => {
+                        total_pages = ph.total_pages;
+                    },
+                    Err(e) => warn!("      ‚ö†Ô∏è Failed to parse X-Pagination: {}", e),
+                }
+            }
+        }
+
+        // 2. Parse Body (Direct Array)
+        let items: Vec<Value> = response.json().await?;
+        let count = items.len();
+
+        // 3. Sync to DB
+        if count > 0 {
+            let synced = db.sync_collection(collection, unique_key, items).await?;
+            info!("      ‚úÖ Synced {}/{} items from Page {}", synced, count, page);
+        } else {
+            debug!("      (Empty Page)");
+        }
+
+        // 4. Loop Logic
+        if page < total_pages as u64 {
+            page += 1;
+        } else {
+            break;
+        }
+    }
+
+    Ok(())
+}
diff --git a/rust-core/wordsynk-ghost/src/storage.rs b/rust-core/wordsynk-ghost/src/storage.rs
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/rust-core/wordsynk-ghost/src/storage.rs
@@ -0,0 +1,42 @@
+use anyhow::Result;
+use mongodb::{options::{ClientOptions, UpdateOptions}, Client, Database};
+use serde_json::Value;
+use bson::{doc, to_document};
+
+pub struct Storage {
+    db: Database,
+}
+
+impl Storage {
+    pub async fn new(uri: &str, db_name: &str) -> Result<Self> {
+        let client_options = ClientOptions::parse(uri).await?;
+        let client = Client::with_options(client_options)?;
+        let db = client.database(db_name);
+        Ok(Self { db })
+    }
+
+    /// Syncs a list of JSON items to a MongoDB collection.
+    /// Performs an upsert based on the `unique_key` field (e.g., "id").
+    pub async fn sync_collection(&self, collection_name: &str, unique_key: &str, items: Vec<Value>) -> Result<usize> {
+        let collection = self.db.collection::<bson::Document>(collection_name);
+        let mut updated_count = 0;
+
+        for item in items {
+            // 1. Convert JSON to BSON
+            let mut bson_doc = to_document(&item)?;
+            
+            // Add a local timestamp for our own tracking
+            bson_doc.insert("_synced_at", bson::DateTime::now());
+
+            // 2. Extract the Unique Key
+            if let Some(id_val) = bson_doc.get(unique_key) {
+                // 3. Upsert
+                let filter = doc! { unique_key: id_val.clone() };
+                let update = doc! { "$set": bson_doc };
+                let options = UpdateOptions::builder().upsert(true).build();
+
+                collection.update_one(filter, update, options).await?;
+                updated_count += 1;
+            }
+        }
+        Ok(updated_count)
+    }
+}